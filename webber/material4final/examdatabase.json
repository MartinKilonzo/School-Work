{
     "questiontemplate": {
        "question": "What is the answer?",
        "answer": "That which was asked for",
        "note": "optional note",
        "source": "SLSW# or ICD# where # is chapter number"
     },
  "description": "questions from which to construct the Winter 2017 final exam in CS3342b",
  "questions": [
     {
        "question": "Adding a feature to a programming language to make it easier to do something that was already doable is called adding ANSWER?",
        "answer": "syntactic sugar",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "Matz, the creator of Ruby, thinks that it is less important to optimize the execution (efficiency) of a programming language and more important to optimize the efficiency of ANSWER",
        "answer": "the programmers",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "A programming language is called ANSWER if it is executed by an interpreter rather than by first being compiled with a compiler",
        "answer": "interpreted",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "If the types of a programming language are bound at execution time rather than compile time, then the types are called ANSWER",
        "answer": "dynamically typed",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In describing the properties of an object oriented language, encapsulation means ANSWER",
        "answer": ["data and behavior are packaged together", "there is a mechanism for restricting access to an object's components"],
        "note": "the first is the textbook answer, but there are actually two usages of the term encapsulation in the object-oriented programming community https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)",
        "source": "SLSW2"
     },
     {
        "question": "In discussing object oriented languages, objects are organized into a class tree to support the property of ANSWER",
        "answer": "inheritance",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In discussing object oriented languages, being able to handle objects of related types is called ANSWER",
        "answer": "polymorphism",
        "note": "polymorphism has a different usage in the object oriented programming community than in the functional programming community",
        "source": "SLSW2# is chapter number"
     },
     {
        "question": "The application that caused a significant increase in the popularity of Ruby was a web framework called ANSWER",
        "answer": "Rails (or Ruby on Rails)",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "The concurrency approach used in Ruby is ANSWER",
        "answer": "threads",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "The command name for the Ruby interpreter is",
        "answer": "irb",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, true.class returns ANSWER",
        "answer": "TrueClass",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "Ruby supports two common ways that boolean expressions are handled in programming languages.  In one approach both subexpressions of a boolean operator are evaluated before the boolean operator is evaluated.  In the other approach, called ANSWER, the first subexpression in a boolean expression is evaluated and if that is enough to know the result of the boolean expression, then the second subexpression is not evaluated.",
        "answer": "short-circuit evaluation",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, normally, when you try to add a String to a Fixnumm, you get an error message saying that a String can't be coerced to a Fixnum.  This is because Ruby is ANSWER typed.",
        "answer": "strongly",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "One way of checking types is to see what constructor was used to create an object that is a parameter.  Another way of checking types is to wait until a method is sent to an object and see if it supports the method.  This second way is called ANSWER",
        "answer": "duck typing",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "A major claim in object oriented design philosophy is that you should code to ANSWER rather than code to implementation",
        "answer": "interface",
        "note": "this is discussed in more detail elsewhere http://www.artima.com/lejava/articles/designprinciplesP.html",
        "source": "SLSW2"
     },
     {
        "question": "The & notation in the line of Ruby def george(&sam) is used to indicate that sam is ANSWER",
        "answer": "a code block",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "The : notation in the Ruby expressions :hi is used to indicate that hi is ANSWER",
        "answer": "a symbol",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "With respect to the value returned by the Ruby expression 'hi'.object_id == 'hi'.object_id, you can say it ANSWER",
        "answer": "could be either true or false",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "With respect to the value returned by the Ruby expression :hi.object_id == :hi.object_id, you can say it ANSWER",
        "answer": "will always be true",
        "note": "optional note",
        "source": "SLSW2# where # is chapter number"
     },
     {
        "question": "To execute a code block in Ruby that is passed to a method but doesn't appear on its parameter list, you use the keyword ANSWER",
        "answer": "yield",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "To execute a code block in Ruby that is passed to a method on its parameter list, you send that parameter the method ANSWER",
        "answer": "call",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "A code block is some lines of code surrounded by either curly braces or ANSWER",
        "answer": "do end",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, the expression Fixnum.class returns ANSWER",
        "answer": "Class",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "The root of the inheritance hierarchy in Ruby is the class ANSWER",
        "answer": "Object",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, the name of the method in the class Me that is automatically invoked when a new object of type Me is created with Me.new is ANSWER",
        "answer": "initialize",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, the @ is used to indicate that the variable @me is ANSWER",
        "answer": "an instance variable",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, the @@ is used to indicate that the variable @@me is ANSWER",
        "answer": "a class variable",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, by convention, the ? in the method me? is used to indicate that me is ANSWER",
        "answer": "boolean",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, the mixin is used to solve the object-oriented programming problem of ANSWER",
        "answer": "multiple inheritance",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "The feature of programs being able to `write programs' (creating application specific language features) is called ANSWER",
        "answer": "metaprogramming",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, if you declare a class with a class name that is already in use and put in it the definition of a new method, you have changed the functionality of the existing class (even if it is a predefined class like Fixnum).  The property of Ruby that allows this is ANSWER",
        "answer": "open classes",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "When you send a message to a Ruby object, Ruby first looks at the methods that object supports, and then starts working the inheritance chain.  If it still can't find the appropriate method, the message and its parameters get passed as a message to the object looking for a method called ANSWER",
        "answer": "method_missing",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In the Ruby community, the acronym DSL is an abbreviation for ANSWER",
        "answer": "domain specific language",
        "note": "optional note",
        "source": "SLSW2"
     },
     {
        "question": "In Ruby, if a line starts with a method name, that method is being sent to the object named ANSWER",
        "answer": "self",
        "note": "this crops up in understanding various example pieces of code in the chapter",
        "source": "SLSW2"
     },
     {
        "question": "When you define a method in a class, normally it is meant to be invoked on an object of that class (an instance method).  Sometimes it is meant to be invoked on the class name itself (a class method), like Date.parse('3rd Feb 2001').  In Ruby, to define a class method, we put ANSWER at the beginning of the method name in its definition.",
        "answer": "self.",
        "note": "this crops up in understanding various example pieces of code in the chapter",
        "source": "SLSW2"
     },
     {
        "question": "Instead of the +  symbol, Haskell uses the symbol ANSWER for a string concatenation operator.",
        "answer": "++",
        "note": "this seems trivial, but think what it says about Haskell that it doesn't just overload + to do concatenation",
        "source": "SLSW8"
     },
     {
        "question": "The type of a string in Haskell, by default, is written ANSWER",
        "answer": "[Char]",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, you use the keyword ANSWER to collect related code into a similar scope",
        "answer": "module",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, if I define a function double = x + x, its type signature would be ANSWER",
        "answer": "(Num a) => a -> a",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, instead of writing something like if x == 0 then 1 else fact ( x - 1 ) * x, you can write a series of lines starting with factorial 0 = 1.  This second style is called ANSWER."
        "answer": "pattern matching",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, instead of writing something like if x == 0 then 1 else fact ( x - 1 ) * x, you can write a series of lines starting with | x > 1 = x * factorial ( x - a).  This second style is called ANSWER."
        "answer": "using guards",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, instead of writing something like second x = head( tail(  x ) ), you can write this without introducing the parameter x by using function composition.  Doing that, you would write ANSWER"
        "answer": "second = head . tail",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, if I write (h:t) = [3, 5, 7], ANSWER is the value of h?"
        "answer": "3",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, if I write (h:t) = [3, 5, 7], ANSWER is the value of t"
        "answer": "[5, 7]",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, ANSWER is the output of zip [17..20] [10,8..4]"
        "answer": "[(17,10),(18,8),(19,6),(20,4)]",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, ANSWER is the output of zip [20..17] [10,8..4]"
        "answer": "[]",
        "note": "default increment is 1 and zip only goes as far as shortest argument list.",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, defining lists using a notation like [x * 2 | x <- [3, 4, 5]] is called using ANSWER"
        "answer": "list comprehensions",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, [x * 2 | x <- [3, 4, 5]]  evaluates to ANSWER"
        "answer": "[6, 8, 10]",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, defining lists using a notation like [x * 2 | x <- [3, 4, 5] is called using ANSWER"
        "answer": "list comprehensions",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, how would you write an anonymous function so that map ANSWER [1, 2, 3] produces [-4, -5, -6]"
        "answer": "(\\x -> - (x + 3))",
        "note": "note above should contain just a single backslash, which in Haskell we would read as lambda",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, if we want to define a local named function inside a function definition, we use the keyword ANSWER"
        "answer": "where",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, the type signature of the function sum x y = x + y is ANSWER"
        "answer": "(Num a) => a -> a -> a",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, given the definition sum x y = x + y, ANSWER is the value of that is produced by the expresion (sum 3)"
        "answer": "(\\x -> 3 + x)",
        "note": "again, that should be just one back slash in the answer, the actual parameter name doesn't matter to the answer as long as it is used consistently",
        "source": "SLSW8"
     },
     {
        "question": "The way Haskell handles functions with more than one parameter is called ANSWER"
        "answer": "currying",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In most languages, a function definition like f a b = a : (f (a + b) b) would result in an infinite recursion.  However, in Haskell we can partially evaluate functions like this because Haskell is based on ANSWER"
        "answer": "lazy evaluation",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "Although Haskell is a statically typed language, we usually don't need to write type declarations because Haskell uses ANSWER to handle the matter."
        "answer": "type inference",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell, we can declare the type of a parameter to a function to be something specific like Num.  However, we can also declare the type of a parameter to be something that could include many types like ListLike that supports the functions head and tail.  We do this with a definition of ListLike that begins with the keyword ANSWER."
        "answer": "class",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "One of the three most significant parts of a monad is called ANSWER, which wraps up a function and puts it in the container",
        "answer": "return",
        "note": "optional note",
        "source": "SLSW8"
     },

     {
        "question": "One of the three most significant parts of a Haskell monad is called ANSWER, which unwraps up a function",
        "answer": [">>=", "a bind function"],
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "In Haskell's do notation for working with monads, assignment uses the ANSWER operator",
        "answer": "<-",
        "note": "optional note",
        "source": "SLSW8"
     },
     {
        "question": "Since Haskell doesn't have traditional error handling, by convention people use the ANSWER monad to distinguish a valid return from an error return",
        "answer": "Maybe",
        "note": "this is similar to NaN's usage in IEEE standard floating point arithmetic",
        "source": "SLSW8"
     },
     {
        "question": "When viewing programming languages as natural languages, the word ANSWER is used instead of `words'",
        "answer": "tokens",
        "note": "optional note",
        "source": "ICD1"
     },
     {
        "question": "The routine in a compiler that takes as input a sequence of characters outputs these characters grouped into meaningful units is called ANSWER",
        "answer": ["a lexical analyzer", "a scanner", "a lexer"],
        "note": "optional note",
        "source": "ICD1"
     },
     {
        "question": "The specifications for how to group characters into meaningful units are traditionally written as ANSWER",
        "answer": "regular expressions",
        "note": "optional note",
        "source": "ICD1"
     },
     {
        "question": "The specifications of how to group characters into meaningful basic units of a programming language are generlly implemented in code that has the abstract form of ANSWER",
        "answer": ["a finite automata", "a finite state machine"],
        "note": "optional note",
        "source": "ICD1"
     },
     {
        "question": "When viewed abstractly, a language is defined as a set of ANSWER",
        "answer": "strings",
        "note": "optional note",
        "source": "ICD1"
     },
     {
        "question": "The Greek letter epsilon, when talking about languages, is used to represent ANSWER",
        "answer": "the empty string",
        "note": "optional note",
        "source": "ICD1"
     },
     {
        "question": "In automatically generating the code that reads characters and outputs the part of a programming language that is analogous to its words, we start with a specification and then traditionally convert it into code in two stages.  In the first stage, we produce ANSWER ",
        "answer": ["a nondeterministic finite automata", "a nondeterministic finite state machine"],
        "note": "optional note",
        "source": "ICD1"
     },
     {
        "question": "In automatically generating the code that reads characters and outputs the part of a programming language that is analogous to its words, we start with a specification and then traditionally convert it into code in two stages.  The main problem that can arise in moving from the first stage to the second stage is ANSWER ",
        "answer": "an exponential explosion in the number of states needed",
        "note": "optional note",
        "source": "ICD1"
     },
     null
  ]
}
